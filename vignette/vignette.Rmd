---
title: "WHO Outbreak Toolkit Virtual Assistant"
author: St√©phane Ghozzi, WHO/WHE/HIM/MDC and RKI/Signale, ghozzis@who.int / ghozzis@rki.de
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  html_document: 
    code_folding: show
    number_sections: yes
    toc: yes
    toc_depth: 4
    toc_float: yes
---

# Initialization

Import libraries.

```{r, setup}
library(readxl)
library(here)
library(dplyr)
library(kableExtra)
library(DT)
library(stringr)
library(ggplot2)
library(tidyr)
library(Rtsne)
library(ISOweek)
library(ggbeeswarm)
library(gridExtra)

knitr::opts_chunk$set(warning = F, message = F, collapse = F, include = T, eval = T, rows.print = 30, 
  cols.min.print = 7)
```

Set parameters, paths, import functions.

```{r}
# Parameters
fake_reference_names <- c('Blue Fever','Danger Fever','Kleptospirosis','Viral Hepatitis Z',
  'West Rhine Virus')
ref_seed <- 1000 # random seed for generating references
min_relative_ext <- 0.1 # minimum extension for float variables, relative to the size of the range and the
                        # size of the range of observations
max_extension_date <- 400 # maximum extension for date variables
linelist_seed <- 100 # random seed for generating line lists
event_n_cases <- 50 # number of cases in generated line lists
noise_strength <- 0.5 # while generating line lists, probability that the values of any variable for any case
                      # are drawn from the data dictionary (i.e. can take any allowed value) rather than from
                      # a reference
maximum_multiplicity <- 3 # maximum multiplicty allowed while generating references
conf_interval_extension <- 0.5 # which confidence interval extension is defined
date_from <- as.Date('2015-1-1') # minimum date while generating line lists
date_to <- as.Date('2019-09-30') # maximum date while generating line lists
n_ref_cases <- 10 # number of reference cases generated when applying t-SNE

# Paths
data_dir <- here('data')
datadictionary_dir <- paste0(data_dir, '/datadictionary')
reference_dir <- paste0(data_dir, '/references')
dir.create(here(reference_dir), showWarnings = F)
fake_ref_dir <- paste0(reference_dir, '/fake')
dir.create(here(fake_ref_dir), showWarnings = F)
real_ref_dir <- paste0(reference_dir, '/real')
linelist_dir <- paste0(data_dir, '/linelists')
dir.create(here(linelist_dir), showWarnings = F)
linelist_fakeref_dir <- paste0(linelist_dir, '/fake_ref')
dir.create(here(linelist_fakeref_dir), showWarnings = F)
linelist_realref_dir <- paste0(linelist_dir, '/real_ref')
dir.create(here(linelist_realref_dir), showWarnings = F)
output_dir <- here('out')
dir.create(here(output_dir), showWarnings = F)

# Functions
source(here('src/ProcessDataDictionary.R'))
source(here('src/GenerateFakeReferences.R'))
source(here('src/ConvertToListMatrix.R'))
source(here('src/ExportDataDictionaryTemplates.R'))
source(here('src/GenerateEventLineList.R'))
source(here('src/ExportReferencesLineLists.R'))
source(here('src/ComputeScores.R'))
source(here('src/PlotScoresGG.R'))
source(here('src/CaseCaseVarDistance.R'))
source(here('src/ComputeDistances.R'))
source(here('src/ComputeTSNE.R'))
source(here('src/PlotTSNEGG.R'))

PrintDF <- function (table_df, which_table) {
  # Custom printing function for data frames, distinguishing between interactive notebook and export
  # If exported, either with kableExtra::kable() (which_table = 'ka') or with 
  # DT::datatable() (which_table = 'dt')
  if(isTRUE(getOption('knitr.in.progress'))) {
    if (which_table == 'ka') {
      return(table_df %>% kable() %>% kable_styling(bootstrap_options = 'striped', font_size = 10, 
        full_width = F))
    } else if (which_table == 'dt') {
      return(datatable(table_df, style = 'bootstrap', extensions = 'Buttons', options = list(dom = 'Blfript',
        scrollX = T, buttons = c('csv', 'excel'))) %>% 
        formatStyle(columns = 1:ncol(table_df), `font-size` = '10px'))
    } else {
      return(error('Unknown table type!'))
    }
  } else {
    return(print(table_df))
  }
}
  
```

# Get the data dictionary

First import and process the data dictionary. 

```{r}
data_dict <- ProcessDataDictionary(datadictionary_dir)
```

It is a data frame, here are the first rows:

```{r}
PrintDF(head(data_dict),'dt')
```

In the following, we use a different format: a matrix of lists, so as to store multiple, named and typed variables and access them easily. As for the data frame, rows are the variables, columns are different properties.

```{r}
data_dict_mat <- ConvertToListMatrix(data_dict,NULL,'datadictionary')
```

For example, accessing the `values` of the variable `notification_facility_type`:

```{r}
print(data_dict_mat[['notification_facility_type','values']])
```

# Generate fake references

From the data dictionary we can generate fake, random references, the number and names of which are set by `fake_reference_names`.

```{r}
fake_ref_list <- GenerateFakeReferences(data_dict_mat,fake_reference_names,min_relative_ext,max_extension_date)
```

Each reference is also a matrix of lists. Here for example the entries for the variable `notification_facility_type` of the first reference:

```{r}
print(fake_ref_list[[1]]['notification_facility_type',])
```

# Import references

We can also import references from CSV files, typically real references defined by experts. Although the CSV format is not very practical from a data management point of view (no types, flat table), it is easily edited, including in Excel, and convenient for people not used to more advanced formats such as JSON or XML. 

```{r}
ref_paths <- list.files(real_ref_dir,full.names=T)
ref_names <- list.files(real_ref_dir)
ref_names <- sapply(ref_names, 
  function (nr) paste(strsplit(gsub('.csv','',nr),'_')[[1]],collapse=' '))
real_ref_list <- list()
for (i in 1:length(ref_paths)) {
  ref_df <- read.csv(ref_paths[i], stringsAsFactors = F)
  ref_mat <- ConvertToListMatrix(ref_df,data_dict_mat,'reference')
  real_ref_list[[ref_names[i]]] <- ref_mat
}
```

Their names are the file names, with the extension removed and underscores replaced with spaces.

```{r}
print(names(real_ref_list))
```

They also are matrices of lists, with rows the variables and columns the reference properties. For example, the entries of the variable `water_drinking_qual` of the first imported reference:

```{r}
print(real_ref_list[[1]]['water_drinking_qual',])
```

# Generate line lists

For each of the two lists of references (fake, i.e. generated; and real, i.e. imported), five line lists are generated that correspond to five types of events: 

1. completely random;
1. all cases drawn from one disease;
1. half of cases drawn from one disease, half from another;
1. all cases drawn from one disease, but noise added, i.e. for each variable of each case, there is a `event_noise` probability that the value is drawn completely at random (otherwise it is drawn from the reference of the disease);
1. half of cases drawn from one disease, half from another, with noise added to all.

```{r}
for (ref_type in c('fake','real')) {
  
  if (ref_type == 'fake') {
    reference_list <- fake_ref_list
  } else if (ref_type == 'real') {
    reference_list <- real_ref_list
  }
  
  linelist_names <- c('Random cases',paste(names(reference_list)[5],'event'),
  paste('Mixed',names(reference_list)[1],'and',names(reference_list)[5],'event'),
  paste('Noisy',names(reference_list)[5],'event'),
  paste('Noisy mixed',names(reference_list)[1],'and',names(reference_list)[5],'event'))
  
  linelist_list <- list()
  
  for (i in 1:length(linelist_names)) {
    
    set.seed(linelist_seed + i)
    
    event_ref_list <- list()
    
    if (i == 1) {
      event_ref_list <- NULL
      event_noise <- 1
    } else if (i == 2) {
      event_ref_list[[names(reference_list)[5]]] <- reference_list[[5]]
      event_noise <- 0
    } else if (i == 3) {
      event_ref_list[[names(reference_list)[1]]] <- reference_list[[1]]
      event_ref_list[[names(reference_list)[5]]] <- reference_list[[5]]
      event_noise <- 0
    } else if (i == 4) {
      event_ref_list[[names(reference_list)[5]]] <- reference_list[[5]]
      event_noise <- noise_strength
    } else if (i == 5) {
      event_ref_list[[names(reference_list)[1]]] <- reference_list[[1]]
      event_ref_list[[names(reference_list)[5]]] <- reference_list[[5]]
      event_noise <- noise_strength
    }
    
    linelist_label <- tolower(gsub(' ','_',linelist_names[i]))
    linelist_generated <- GenerateEventLineList(data_dict_mat, event_ref_list, event_noise, event_n_cases, 
      maximum_multiplicity, conf_interval_extension, linelist_label, date_from, date_to)
    
    linelist_list[[linelist_names[i]]] <- linelist_generated
  }
  if (ref_type == 'fake') {
    fake_linelist_list <- linelist_list
  } else if (ref_type == 'real') {
    real_linelist_list <- linelist_list
  }
}
```

Line lists are again matrices of lists, with rows the cases and columns the variables. For example, the `mass_gathering_date` values of the first case of the first event drawn from the generated (fake) references:

```{r}
print(fake_linelist_list[[1]][1,'mass_gathering_date'])
```

# Export templates, data dictionary, (fake) references and line lists

The data dictionary can be exported to CSV (e.g. to be used in the Shiny app). Similarly templates for references and line lists can be exported, if someone wants to fill them manually. Lastly, the generated references and line lists can be exported to CSV as well, e.g. to be later loaded in the Shiny app.

Here also, the CSV format is chosen for human readability and editability.

```{r}
ExportDataDictionaryTemplates(data_dict,datadictionary_dir,reference_dir,linelist_dir)
ExportReferencesLineLists(fake_ref_list,fake_ref_dir)
ExportReferencesLineLists(fake_linelist_list,linelist_fakeref_dir)
ExportReferencesLineLists(real_linelist_list,linelist_realref_dir)
```

# Compute and plot scores

From references and line lists the scores can computed, plotted and saved as PDF, individually or combined. 

```{r}
for (ref_type in c('fake','real')) {
  
  if (ref_type == 'fake') {
    linelist_list <- fake_linelist_list
    reference_list <- fake_ref_list
  } else if (ref_type == 'real') {
    linelist_list <- real_linelist_list
    reference_list <- real_ref_list
  }
  
  score_plot_list <- list()
  for (nl in names(linelist_list)) {
   
    scores <- ComputeScores(linelist_list[[nl]], nl, reference_list, data_dict_mat)
    score_plot <- PlotScoresGG(linelist_list[[nl]], scores, ref_type, output_dir, save_pdf=T)
    score_plot_list[[nl]] <- score_plot
     
  }
  
  score_plot_grid <- arrangeGrob(grobs = score_plot_list, ncol=3)
  ggsave(plot = score_plot_grid, file = paste0(output_dir, '/score_plots_', ref_type, '.pdf'),
    units = 'cm', width = 40, height = 20)
}
```

For example, the score distributions of the second event for the imported (real) references:

```{r}
score_plot_list[[2]]
```

# Compute distances, apply and plot t-SNE

Lastly, to visualise cases and references in 2 dimensions, distances between cases, including newly generated reference cases, are first computed. This takes about 5 minutes for overall 10 events (5 for each of both sets of references, fake and real).

```{r}
ref_cases_list <- list()
for (ref_type in c('fake','real')) {
  
  if (ref_type == 'fake') {
    linelist_list <- fake_linelist_list
    reference_list <- fake_ref_list
  } else if (ref_type == 'real') {
    linelist_list <- real_linelist_list
    reference_list <- real_ref_list
  }
  
  ref_cases <- matrix(list(),nrow=0,ncol=1+nrow(data_dict_mat))
  for (i in 1:length(reference_list)) {
    set.seed(ref_seed+i)
    nr <- names(reference_list)[i]
    event_ref_list <- list()
    event_ref_list[[nr]] <- reference_list[[i]]
    cases <- GenerateEventLineList(data_dict_mat,event_ref_list,0,n_ref_cases,maximum_multiplicity,
      conf_interval_extension,paste0('ref_', tolower(gsub(' ','_',nr))),date_from,date_to)
    ref_cases <- rbind(ref_cases, cases)
  }
  ref_cases_list[[ref_type]] <- ref_cases
  
  tsne_plot_list <- list()
  for (nl in names(linelist_list)) {
  
    distances <- ComputeDistances(rbind(ref_cases,linelist_list[[nl]]),reference_list,data_dict_mat,F)
    tsne_projection <- ComputeTSNE(distances,linelist_list[[nl]],nl,reference_list,n_ref_cases)
    tsne_plot <- PlotTSNEGG(tsne_projection,nl,ref_type,output_dir,save_pdf=T)
    tsne_plot_list[[nl]] <- tsne_plot
    
  }
  
  tsne_plot_grid <- arrangeGrob(grobs = tsne_plot_list, ncol=3)
  ggsave(plot = tsne_plot_grid, file = paste0(output_dir, '/tsne_plots_', ref_type, '.pdf'),
    units = 'cm', width = 40, height = 20)
}
```

For example, the 2d visualisation of the second event for the imported (real) references:

```{r}
tsne_plot_list[[2]]
```


One can also try to apply t-SNE to the few scores of the cases instead of all variables. There one doesn't need to compute a distance.

```{r}
for (ref_type in c('fake','real')) {
  
  if (ref_type == 'fake') {
    linelist_list <- fake_linelist_list
    reference_list <- fake_ref_list
  } else if (ref_type == 'real') {
    linelist_list <- real_linelist_list
    reference_list <- real_ref_list
  }
  ref_cases <- ref_cases_list[[ref_type]]
  
  tsne_score_plot_list <- list()
  for (nl in names(linelist_list)) {    
    
    scores_refs <- ComputeScores(ref_cases, nl, reference_list,
      data_dict_mat) %>% spread(reference, s1) %>% select(-case_id,-linelist)
    rownames(scores_refs) <- rownames(ref_cases)
    scores_cases <- ComputeScores(linelist_list[[nl]], nl, reference_list,
      data_dict_mat) %>% spread(reference, s1) %>% select(-case_id,-linelist)
    rownames(scores_cases) <- rownames(linelist_list[[nl]])
    
    cases_scores_tsne <- Rtsne(rbind(scores_refs,scores_cases), theta = 0,
      perplexity = (nrow(rbind(scores_refs,scores_cases))-1)/3)
    tsne_score_projection <- data.frame(x=cases_scores_tsne$Y[,1],y=cases_scores_tsne$Y[,2],
      reference = c(sapply(names(reference_list), function (nr) rep(nr,n_ref_cases)),
        rep(nl, nrow(linelist_list[[nl]]))), case_id = rownames(rbind(scores_refs,scores_cases)))
    tsne_score_plot <- PlotTSNEGG(tsne_score_projection,nl,paste0('scores-', ref_type),output_dir,save_pdf=T)
    tsne_score_plot_list[[nl]] <- tsne_score_plot
  }

  tsne_score_plot_grid <- arrangeGrob(grobs = tsne_score_plot_list, ncol=3)
  ggsave(plot = tsne_score_plot_grid, file = paste0(output_dir, '/tsne_score_plots_', ref_type, '.pdf'),
    units = 'cm', width = 40, height = 20)
  
}
```

For example, the 2d visualisation of the second event for the imported (real) references:

```{r}
tsne_score_plot_list[[2]]
```

